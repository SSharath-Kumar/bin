#!/bin/bash

set -e

DEFAULT_FILE=".git-blame-ignore-revs"

HELP=$(cat <<EOF
Usage: $(basename "$0") [FILE]

Adds the last Git commit hash to a specified file (default: $DEFAULT_FILE)

Options:
  FILE         Specify the file to update. Defaults to "$DEFAULT_FILE".
  -h, --help   Show this help message and exit.

Example:
  $(basename "$0")                # Use $DEFAULT_FILE
  $(basename "$0") custom-file    # Use "custom-file" instead
EOF
)
if [[ "$1" == "-h" || "$1" == "--help" ]]; then
    echo "$HELP"
    exit 0
fi

FILE=${1:-$DEFAULT_FILE}

if [ ! -d .git ]; then
    echo "This script must be run in the root of a Git repository."
    exit 1
fi

echo "Getting the last commit hash..."
LAST_HASH=$(git log -1 --pretty=format:"%H" 2>/dev/null || echo)

if [ -z "$LAST_HASH" ]; then
    echo "No prior commits found. Please make an initial commit before running this script."
    exit 1
fi

SHORT_HASH=$(echo "$LAST_HASH" | cut -c 1-7)

CREATE_OR_UPDATE="update"
if [ -f "$FILE" ]; then
    if grep -qE "^\s*$SHORT_HASH" "$FILE"; then
        echo "Hash already exists in $FILE. Skipping."
        exit 0
    fi
else
    echo "Creating $FILE with the last commit hash."
    CREATE_OR_UPDATE="create"
fi

if git status --short "$FILE" | grep -q "^[ MADRCU?]"; then
    echo "The file $FILE has unstaged changes."
    printf "Are you sure you want to proceed (y/n)? "
    read -r confirm
    confirm=${confirm:-n}
    case "$confirm" in
        [yY][eE][sS]|[yY]) ;;
        *) echo "Aborted."; exit 1 ;;
    esac
fi

STASHED=false
if [ -n "$(git diff --cached)" ]; then
    echo "There are staged changes. Stashing them temporarily..."
    git stash push -k -m "Temporary stash for add-last-commit-hash"
    STASHED=true
    echo "Staged changes stashed."
fi

{
    echo "$LAST_HASH" >> "$FILE"
    git add "$FILE"
    COMMIT_MSG="docs: update $FILE"
    FILE_COUNT=$(git diff --cached --name-only | wc -l)

    if [ "$FILE_COUNT" -eq 1 ]; then
        FILE_NAME=$(git diff --cached --name-only)
        FILE_LENGTH=${#FILE_NAME}
        if [ "$FILE_LENGTH" -gt 1 ] && [ "$FILE_LENGTH" -le 14 ]; then
            COMMIT_MSG="docs($FILE_NAME): $CREATE_OR_UPDATE $FILE"
        fi
    fi

    MSG_LENGTH=${#COMMIT_MSG}
    if [ "$MSG_LENGTH" -lt 38 ]; then
        COMMIT_MSG="$COMMIT_MSG with $SHORT_HASH"
    fi

    git commit --no-verify -m "$COMMIT_MSG"
    echo "Successfully updated and committed $FILE."
    UPDATED=true
} || {
    echo "Failed to update $FILE. Resolve manually."
    UPDATED=false
}

if [ "$STASHED" = true ]; then
    echo "Reapplying stashed changes..."
    git stash pop || { echo "Failed to apply stashed changes. Resolve manually."; exit 1; }
fi

if [ "$UPDATED" = false ]; then
    exit 1
fi
